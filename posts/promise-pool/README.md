# Promise Pool로 성능 개선하기

Node.js 환경에서는 다수의 비동기 작업을 처리하기에 적합하다.  
예를 들어, 다음과 같은 상황이 있다고 가정해보자.

- ID 별로 조회만 가능한 외부 서비스에서 대량의 건수를 API로 조회해야하는 경우
- `join`, `subquery` 로 조회시 성능과 DB의 부하가 심하여, `id` 별로 쿼리를 나눠서 조회해야하는 경우
- 대량으로 이벤트 메세지를 발행해야하는 경우

등등 다량의 비동기 작업들은 백엔드 애플리케이션 작업에서는 언제든지 발생할 수 있다.  
이럴때 보통은 `promise.all` 을 통해 처리하게 된다.  

여러 비동기 작업들을 수행할 수 있게 해주는 `promise.all` 을 활용할 경우 **데이터베이스의 커넥션풀 제한** 등을 고려해서 적당량의 chunk로 분할해서 `promise.all`을 수행한다.  
  
즉, 데이터베이스의 커넥션 풀이 50개인 상황에서, 1,000개의 쿼리 수행이 필요하다면 보통은 50개 이하의 단위 (chunk) 로 Promise 배열을 만들어 이들을 `promise.all` 로 수행한다.  
(보통은 이럴때 chunk를 50개로 잡지 않는다.  다른 서버들도 여러 쿼리들이 수행될 수 있기 때문에 적당히 낮은 값으로 잡는다.)
  

![promiseall](./images/promiseall.png)

![promisepool](./images/promisepool.png)

## 주의

실제 서비스에서 대규모의 트래픽 상태에서 검증한 것이 아니고 한정된 자원내에서의 성능 테스트이기 때문에 실제 서비스 적용전에는 충분한 검증이 필요합니다.

## 개요

비동기를 레일로 만들어서 작동시킨다는 것을 이걸 보통 Promise Pool 이라고 합니다.
데이터베이스의 Connection Pool처럼 Promise 객체를 Pool로 관리한다고 하여
보통 너무 많은 Promise객체들을 처리해야할때 Chunk 단위로 쪼개서 하게 되는데요.
이렇게 되면 각 chunk 단위의 가장 긴 작업들의 총합이 곧 총 작업시간이 됩니다.


하지만 Promise Pool로 처리하면
Pool 안에서 끝나는대로 그 빈자리를 계속해서 채워서 처리하기 때문에 성능 개선이 가능합니다.


예를 들어 데이터베이스에 부담을 주지 않기 위해 4개의 프로미스만 동시에 실행되도록 허용하는 등 동시성을 제어하고 싶다고 가정해 보겠습니다. 어떻게 할 수 있을까요?

Promise.all()은 이 점에서 제한적입니다.

해결책은 프로미스 풀을 사용하는 것입니다.

많은 프로미스 풀 라이브러리가 있지만, @supercharge/promise-pool은 다른 라이브러리보다 제가 선호하는 멋진 API를 제공합니다.

https://github.com/supercharge/promise-pool
https://github.com/timdp/es6-promise-pool