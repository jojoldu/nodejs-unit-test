# 내부 구현 검증을 최대한 피하기

이미 추상화하여, 내부로직을 숨긴 클래스를 다시 내부로직을 드러내게 하는 것과 다를 바 없다.  


내부 구현 로직이 조금만 변경되어도 테스트가 깨질 가능성이 높아진다.  
실행 결과 즉, 최종 결과를 목표로 해서 테스트를 검증해야만 한다

다만, 기존 로직에 테스트 코드를 추가할때는 내부 구현을 검증할 수도 있다.  

리팩토링만 하면 테스트가 깨지는 경우가 보통 이 경우이다.  
구현을 조금만 변경해도 테스트가 깨질 가능성이 커진다.  

내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현 보다 최종 결과를 검증해야한다  

## Mock 
대표적인 예로 모의 객체 (Mock 객체)를 호출하는지 여부를 확인하는 것이다.  
모의 객체 호출 여부를 확인하는 것은 구현을 검증하는 것이지만,  
최종 결과에 대해 확인하는 것은 설계를 검증하는 것이다.

테스트는 고객 오브젝트의 내부 구현에 대해 알지 못한다. 
테스트는 오로지 고객 오브젝트가 어떤 식으로 다른 오브젝트와 상호작용하는지만 알고 있습니다. 물론 다른 오브젝트는 상황에 따라 모킹될 수 있습니다. 또 테스트가 기술적인 세부사항보다 비즈니스 요구사항을 나타내고 있다는 점도 중요한 포인트이다.

고객 오브젝트의 내부 구현이 변경되더라도 위 테스트는 살아남을 것입니다. 고객 오브젝트를 생성하는 코드는 바뀔 수 있겠지만 그 코드는 createSampleCustomer()와 같은 헬퍼를 통해 한 곳에서 관리되어야 한다.

기능을 추가하면서 지속적으로 리팩토링을 해야한다면 테스트가 내부 구현과 강하게 결합되어 있다는 것을 의미합니다.
