# 테스트하기 좋은 코드

팀의 개발자들과 함께 [NextStep - 이펙티브 코틀린 강좌](https://edu.nextstep.camp/c/Z9QeJlCi)를 수강하고 있다.    
지난주에 과제 회고를 처음 진행했는데, 이때 나온 주제가 **테스트 하기 좋은 코드**였다.  
이 주제는 사실 이미 너무 많이 회자된 주제이다.  
관련된 좋은 컨텐츠도 충분하다.  
대표적으로 아래 2개이다.  
  
* [정진욱님 - Testing, Oh my!](https://jwchung.`github.io/testing-oh-my)
* [권용근님 - 무엇을 테스트할 것인가](https://www.youtube.com/watch?v=YdtknE_yPk4)

> 이 컨텐츠들을 다 보았다면, 굳이 이 글을 볼 필요는 없다.

너무 좋은 컨텐츠들이지만 아쉽게도 JS/TS 컨텐츠가 아니다. (C#, Java)    
  
그러다보니 JS/TS만 해온 우리팀 분들 (+프론트엔드 개발팀원포함)과 앞으로 입사할 신규 입사자들을 위해 한번 정리하려고 한다.  

> 뒤에 이어 쓸 Active Record vs Data Mapper의 빌드업이기도 하다.

## 테스트 하기 좋은 코드?

테스트 코드 작성의 어려움을 팀원들을 보면 본인이 테스트 코드를 작성해본 경험이 부족해서 혹은 테스트 프레임워크 (JUnit, Jest 등) 숙련도가 떨어지기 때문이라고 생각하는 경우를 종종 본다.  
  
하지만 테스트 코드 경험, 테스트 프레임워크 숙련도로 인한 어려움은 생각보다 큰 이유가 아니다.  
거의 대부분은 **테스트 대상 자체가 테스트 코드를 작성하기 어렵게 구현**되었기 때문이다.  
  
이런 이야기를 하면, 자주 나오는 질문 중 하나가 있다.  
마침 이번주 과제 회고 시간에도 또 나왔다.  
그 질문은 다음과 같다.  

"테스트를 위해서 원본 코드의 구현과 설계를 고치는게 맞는건가요?"  
  
얘기를 좀 더 나눠보니 이 질문이 나온 배경을 조금 알 수 있었다.  
"**테스트는 구현의 보조적인 수단인데**, 이를 위해 구현부 설계가 교체되는게 옮은것인가" 하는 것이었다.  
  
이 질문에 대해 그 리뷰 자리에서도 확실하게 말씀드렸다.  
  
"테스트 코드는 구현의 보조적인 수단이 아니며, 같은 레벨로 봐야한다.  
테스트 하기 좋은 코드가 대체적으로 좋은 설계로 된 코드이다.  
**테스트 하기 어렵게 코드가 되었다면, 코드 확장성 / 의존성 등 코드 디자인/설계가 잘못되었을 확률이 굉장히 높다**"  

이와 비슷한 예제의 글도 과거에 작성한적이 있다.

* [@SpyBean @MockBean 의도적으로 사용하지 않기](https://jojoldu.tistory.com/320)

**테스트 코드는 절대 구현부의 보조수단이 아니다**.  
오히려 구현부 설계 스멜을 맡게 해주는 좋은 수단이다.  
  




  
즉, 테스트 코드 작성이 어렵다고 테스트 프레임워크와 테스트 코드 작성법을 계속 공부할게 아니라 테스트 대상 코드를 테스트하기 좋도록 구현하는게 더 

이런 답변을 하면 추가로 들어오는 질문이 있다.  

"Cypress, Supertest 등을 통해 E2E 테스트를 작성하면 안되나요?"  
실제로, 입사 과제를 치루시는 많은 지원자분들 역시 **단위 테스트는 모두 Mocking으로 처리하고 비지니스 로직은 모두 E2E로만 검증**하는 경우가 대다수였다.


* 테스트 구현의 복잡함
* 빠른 피드백 불가능

## 테스트하기 좋은 코드 vs 테스트하기 어려운 코드

몇번을 수행해도 항상 같은 결과가 발생하는 순수함수
순수함수를 방행하는 2가지 큰 요소

* 제어할 수 없는 코드
  * `Random()`
  * `new Date()` 혹은 `LocalDate.now()`
  * 데이터베이스/API 등 외부에서 가져온 결과를 사용하는 코드
* 부수효과 (Side Effect)
  * 이메일 발송
  * 로깅
  * 데이터베이스 / API 등으로 데이터 전송하는 코드


그런면에 있어서 TS와 같은 언어는 **외부의 세상에 영향을 주는 것**을 `async` 로 구분할 수 있다.
`async` 함수(혹은 메소드)는 테스트하기 어려운 코드로 봐도 무방하다.
즉, `async` 함수 (혹은 메소드)를 얼마나 핵심에서 벗어나게 하느냐가 프로젝트 전체의 테스트 용이성을 결정한다.

## 

흔히 말하는 Controller-Service-Repository 패턴이라면 Repository 가 

실제로는 Controller -> Service -> Domain <- Repository 가 된다.
즉, 

### BE

DB에서 값을 가져오는 코드

### FE

Cookie 나 로컬 스토리지를 통해 값을 가져오는 코드

## 

다음과 같이 시그널을 캐치할 수 있다.

> private 메소드가 많다면 클래스로 분리하는 것을 고려해보자

