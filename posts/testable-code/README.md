# 테스트하기 좋은 코드

팀분들과 함께 [NextStep - 이펙티브 코틀린 강좌](https://edu.nextstep.camp/c/Z9QeJlCi)를 수강하고 있다.    
지난주에 과제 회고를 처음 진행했는데, 이때 나온 주제가 **테스트 하기 좋은 코드**였다.  
이 주제는 사실 이미 너무 많이 회자된 주제이다.  
관련된 좋은 컨텐츠도 충분하다.  
대표적으로 아래 2개이다.  
  
* [정진욱님 - Testing, Oh my!](https://jwchung.`github.io/testing-oh-my)
* [권용근님 - 무엇을 테스트할 것인가](https://www.youtube.com/watch?v=YdtknE_yPk4)

> 이 컨텐츠들을 다 보았다면, 굳이 이 글을 볼 필요는 없다.

너무 좋은 컨텐츠들이지만 아쉽게도 JS/TS 컨텐츠가 아니다. (C#, Java)    
  
그러다보니 JS/TS만 해온 우리팀 분들 (+프론트엔드 개발팀원포함)과 앞으로 입사할 신규 입사자들을 위해 정리가 필요했다.  

> 뒤에 이어 쓸 Active Record vs Data Mapper의 빌드업이기도 하다.

## 테스트 하기 좋은 코드?

테스트 코드 작성의 어려움을 팀원들을 보면 본인이 테스트 코드를 작성해본 경험이 부족해서 혹은 테스트 프레임워크 (JUnit, Jest 등) 숙련도가 떨어지기 때문이라고 생각하는 경우를 종종 본다.  
  
하지만 테스트 코드 경험, 테스트 프레임워크 숙련도로 인한 어려움은 생각보다 큰 이유가 아니다.  
경험상 대부분은 **테스트 대상 자체가 테스트 코드를 작성하기 어렵게 구현**되었기 때문이였다.    
  
애초부터 테스트하기 어렵도룩 구현되었기 때문에, 테스트 코드 작성이 어려운 것이지, 도구의 숙련도의 문제인 경우가 별로 없다.  
좀 더 극단적으로는 **테스트 코드 작성이 쉽게 구현된 코드라면 별도의 Mock 라이브러리 등의 도움 없이도 테스트 코드 작성이 쉽다**.  
  
그렇다면 2가지가 궁금할 수 있다.

* 테스트 하기 좋은 코드란 어떤 코드인가?
* 테스트 코드가 구현 코드의 설계를 바꿀 정도로 중요한것인가?

첫번째 질문에 대한 답은 본문에서 자세히 설명할 예정이다.  
두번째 질문에 대해서 먼저 이야기하고싶다.  

> 마침 이번주 과제 회고 시간에도 나왔던 질문이였다.  

"테스트를 위해서 원본 코드의 구현과 설계를 고치는게 맞는건가요?"  
  
이 질문의 의도가 무엇인가 곰곰히 생각을 하면 다음과 같다.  

"**테스트는 구현의 보조적인 수단인데**, 이를 위해 구현부 설계가 교체되는게 옮은것인가" 하는 것이었다.  
  
이 질문에 대해서는 명확하게 답해드릴 수 있다.  

"**테스트를 위해 구현 설계가 변경되는게 당연하다**.  
테스트 코드는 구현의 보조적인 수단이 아니며, 같은 레벨로 봐야한다.  
테스트 하기 좋은 코드가 대체적으로 좋은 설계로 된 코드이다.  
**테스트 하기 어렵게 구현 되었다면, 코드 확장성 / 의존성 등 코드 디자인, 설계가 잘못**되었을 확률이 굉장히 높다."  
  
이 문제를 실제로 만나서 작성하게 된 글도 있다.

* [@SpyBean @MockBean 의도적으로 사용하지 않기](https://jojoldu.tistory.com/320)

**테스트 코드는 절대 구현부의 보조수단이 아니다**.  
오히려 **구현 설계 Smell**을 맡게 해주는 좋은 수단이다.  
  
  
즉, 테스트 코드 작성이 어렵다고 테스트 프레임워크와 테스트 코드 작성법을 계속 공부할게 아니라 테스트 대상 코드를 테스트하기 좋도록 구현하는게 더 

이런 답변을 하면 추가로 들어오는 질문이 있다.  

"Cypress, Supertest 등을 통해 E2E 테스트를 작성하면 안되나요?"  
실제로, 입사 과제를 치루시는 많은 지원자분들 역시 **단위 테스트는 모두 Mocking으로 처리하고 비지니스 로직은 모두 E2E로만 검증**하는 경우가 대다수였다.


* 테스트 구현의 복잡함
* 빠른 피드백 불가능

## 테스트하기 좋은 코드 vs 테스트하기 어려운 코드

몇번을 수행해도 항상 같은 결과가 발생하는 순수함수
순수함수를 방행하는 2가지 큰 요소

* 제어할 수 없는 코드
  * `Random()`
  * `new Date()` 혹은 `LocalDate.now()`
  * 데이터베이스/API 등 외부에서 가져온 결과를 사용하는 코드
* 부수효과 (Side Effect)
  * 이메일 발송
  * 로깅
  * 데이터베이스 / API 등으로 데이터 전송하는 코드


그런면에 있어서 TS와 같이 외부와의 연동이 필요한 경우 항상 `async`가 필요한 경우는 구분하기가 편하다.  
`async` 가 들어가면 **외부의 세상에 영향을 주는 것**으로 구분하는 것이다.  

즉, `async` 함수는 테스트하기 어려운 코드로 봐도 무방하기 때문에 `async` 함수를 **얼마나 핵심 로직에서 벗어나게 하느냐**가 프로젝트 전체의 테스트 용이성을 결정한다.

## 

흔히 말하는 Controller-Service-Repository 패턴이라면 Repository 가 

실제로는 Controller -> Service -> Domain <- Repository 가 된다.
즉, 

### BE

DB에서 값을 가져오는 코드

### FE

Cookie 나 로컬 스토리지를 통해 값을 가져오는 코드

## 

다음과 같이 시그널을 캐치할 수 있다.

> private 메소드가 많다면 클래스로 분리하는 것을 고려해보자

