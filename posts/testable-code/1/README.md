# 1. 테스트하기 좋은 코드 - 

팀 분들과 함께 [NextStep - 이펙티브 코틀린 강좌](https://edu.nextstep.camp/c/Z9QeJlCi)를 수강하고 있다.    
최근에 과제 회고를 처음 진행했는데, 이때 나온 주제가 **테스트 하기 좋은 코드**였다.  
이 주제는 사실 이미 너무 많이 회자된 주제이다.  
관련된 좋은 컨텐츠도 충분하다.  
대표적으로 아래 2개이다.  
  
* [정진욱님 - Testing, Oh my!](https://jwchung.github.io/testing-oh-my)
* [권용근님 - 무엇을 테스트할 것인가](https://www.youtube.com/watch?v=YdtknE_yPk4)

> 이 컨텐츠들을 다 보았다면, 굳이 이 글을 볼 필요는 없다.

너무 좋은 컨텐츠들이지만 아쉽게도 JS/TS 컨텐츠가 아니다. (C#, Java)    
  
그러다보니 JS/TS만 해온 기존팀원들과 앞으로 입사할 신규 입사자들을 위해 정리가 필요했다.  

> 뒤에 이어 쓸 Active Record vs Data Mapper의 빌드업이기도 하다.

이 글에서는 테스트하기 좋은 코드에 대해 이야기해보려고 한다.

## 1. 테스트 하기 좋은 코드?

> 여기서 이야기하는 테스트는 **단위 테스트를 의미한다**.  
> E2E 테스트는 여기서 이야기하는 테스트와 구현, 설계와는 다르다.

테스트 코드 작성의 어려움을 팀원들을 보면 본인이 테스트 코드를 작성해본 경험이 부족해서 혹은 테스트 프레임워크 (JUnit, Jest 등) 숙련도가 떨어지기 때문이라고 생각하는 경우를 종종 본다.  
  
하지만 테스트 코드 작성 경험, 테스트 프레임워크 숙련도로 인한 어려움은 생각보다 큰 이유가 아니다.  
경험상 대부분은 **테스트를 작성하기 어려운 구현체** 때문이다.  
  
테스트하기 어렵도룩 구현되었기 때문에 테스트 코드 작성이 어려운 것이지, 도구의 숙련도의 문제인 경우가 별로 없다.  
좀 더 극단적으로는 **테스트 코드 작성이 쉽게 구현된 코드라면 별도의 Mock 라이브러리 등의 도움 없이도 테스트 코드 작성이 쉽다**.  
  
그렇다면 2가지가 궁금할 수 있다.

* 테스트 코드가 구현 코드의 설계를 바꿀 정도로 중요한것인가?
* 테스트 하기 좋은 코드란 어떤 코드인가?

두번째 질문은 앞으로 자세한 설명을 할 예정이기 때문에,  
여기서는 첫번째 질문에 대해서 먼저 이야기하고 싶다.  
  
마침 이번주 NextStep 과제 회고 시간에 같은 질문이 나왔다. 
  
"**테스트를 위해서 원본 코드의 구현과 설계를 고치는게 맞는건가요?**"  
  
이 질문의 의도가 무엇인가 곰곰히 생각을 해보면 다음과 같다.  
  
"**테스트는 구현의 보조적인 수단인데**, 이를 위해 구현부 설계가 교체되는게 옮은것인가" 하는 것이었다.  
  
이 질문에 대해서는 명확하게 답해렸다.  

"**테스트를 위해 구현 설계가 변경될 수 있다**.  
테스트 코드는 구현의 보조적인 수단이 아니며, 같은 레벨로 봐야한다.  
**좋은 디자인으로 구현된 코드는 대부분 테스트 하기가 쉽다**.    
테스트 하기 어렵게 구현 되었다면, 코드 확장성 / 의존성 등 코드 디자인, 설계가 잘못되었을 확률이 굉장히 높다."  
  
**테스트 코드는 구현의 보조 수단이 절대 아니다**.  
오히려 **구현 설계 Smell**을 맡게 해주는 좋은 수단이다.  
  
실제로 이 설계 문제를 만나서 작성한 글도 있다.

* [@SpyBean @MockBean 의도적으로 사용하지 않기](https://jojoldu.tistory.com/320)
  
지금 테스트 코드 작성이 어렵다면, 구현부의 코드를 다시 한번 점검해보자.  
테스트 작성이 어렵도록 구현된게 아닌지 말이다.

## 2. 테스트하기 좋은 코드 vs 테스트하기 어려운 코드

그렇다면 테스트하기 좋은 코드란 무엇일까?  
  
경험상으로 **멱등성이 보장되는 순수 함수**가 테스트 하기 좋은 코드였다.  
즉, 몇번을 수행해도 항상 같은 결과가 발생하는 함수이다.  
몇번을 수행해도 항상 같은 결과가 나오기 위해서는 아래 2가지 요소를 최대한 피해해야만 한다.

### 2-1. 제어할 수 없는 값에 의존하는 경우

아래와 같이 **개발자가 제어할 수 없는 값에 의존**하는 함수인 경우는 테스트하기가 어렵다.

* `Random()`, `new Date()` (`LocalDate.now()`) 와 같이 실행할때마다 결과가 다른 함수에 의존하는 경우
* `readLine` 등과 같은 사용자들의 입력에 의존하는 경우
* **데이터베이스/API** 등 외부에서 가져온 결과를 사용하는 코드

이를테면 다음과 같은 함수일 경우 테스트 작성이 어렵다.

```ts

```

### 외부에 영향을 주는 코드

두번째로 

* `console.log`, `System.out.println()` 과 같은 표준 출력
* 로깅
* 이메일 발송, 메세지큐 등 외부로의 메세지 발송
* 데이터베이스 등으로 외부에 데이터를 저장하는 경우


그런면에 있어서 TS와 같이 **외부와의 연동이 필요한 경우** 항상 `async`가 필요한 경우는 구분하기가 편하다.  
**외부의 세상에 영향을 주는 것**인지 구분을 `async` 함수인지로 구분하면 되기 때문이다.  

즉, (TypeScript 등의 경우) `async` 함수는 테스트하기 어려운 코드로 봐도 무방하기 때문에 `async` 함수를 **얼마나 핵심 로직에서 벗어나게 하느냐**가 프로젝트 전체의 테스트 용이성을 결정한다.

### 2-3. 실제 예제


특히 오래된 프로젝트를 보면, 다음과 같이 **제어할 수 없는 함수**가 굉장히 많다.

다음과 같은 코드는 **테스트 작성이 너무나 어렵다**.

```sql
query(`
  SELECT *
  FROM table
  WHERE created_at <= NOW()
`);
```



이 테스트는 왜 테스트 작성이 너무나 어려운것일까?

* 실행할때마다 변경되는 현재 시간 쿼리 함수 (`NOW()`) 를 쿼리 내부에서 쓰고 있다
* 
* 현재 테스트로 사용중인 데이터베이스에 