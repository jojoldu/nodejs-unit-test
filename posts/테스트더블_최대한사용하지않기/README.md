# 테스트 더블 (Mock, Stub, Spy) 최대한 사용하지 않기

## 테스트 더블 (모의객체) 사용시 문제

### 테스트 단위의 문제

모든 테스트는 코드 단위 (클래스 혹은 함수/메소드)가 검증 단위가 되어야하는 것이 아니라, 행동 (동작)
이 검증의 단위가 되어야 한다.  

모의 테스트를 작성할 때 SUT의 아웃바운드 호출을 테스트하여 공급자와 제대로 통신하는지 확인합니다. 고전적인 테스트는 최종 상태에만 관심이 있고 그 상태가 어떻게 파생되었는지는 중요하지 않습니다. 따라서 Mockist 테스트는 메서드 구현과 더 많이 연결됩니다. 공동 작업자에 대한 호출의 특성을 변경하면 일반적으로 모의 테스트가 중단됩니다.

이 결합은 몇 가지 문제를 야기합니다. 가장 중요한 것은 테스트 주도 개발에 대한 영향입니다. 모의객체 테스팅을 사용하면 테스트를 작성하면 동작 구현에 대해 생각하게 됩니다. 실제로 모의객체 테스터는 이것을 장점으로 봅니다. 그러나 고전주의자들은 외부 인터페이스에서 일어나는 일만 생각하고 테스트 작성을 완료할 때까지 구현에 대한 모든 고려 사항을 남겨두는 것이 중요하다고 생각합니다.

구현에 대한 결합은 또한 리팩토링을 방해합니다. 구현 변경으로 인해 기존 테스트보다 테스트가 중단될 가능성이 훨씬 더 높기 때문입니다.

이것은 모의 툴킷의 특성으로 인해 악화될 수 있습니다. 종종 모의 도구는 이 특정 테스트와 관련이 없는 경우에도 매우 구체적인 메서드 호출 및 매개변수 일치를 지정합니다. jMock 툴킷의 목표 중 하나는 리팩토링을 더 까다롭게 만들 수 있는 문자열을 사용하는 대가로 중요하지 않은 영역에서 기대치를 더 느슨하게 할 수 있도록 기대치를 보다 유연하게 지정하는 것입니다.

### 디자인 스멜

마틴파울러의 리팩토링2에서 나온 비유를 따오자면,  
옷에 나는 악취를 해결하기 위해 세탁을 하지 않고, **탈취제를 뿌리는 행위**와 같다.  

나에게 이러한 테스트 스타일의 가장 매력적인 측면 중 하나는 디자인 결정에 영향을 미치는 방식입니다. 두 유형의 테스터와 이야기하면서 스타일이 권장하는 디자인 사이의 몇 가지 차이점을 알게 되었지만 표면을 거의 긁고 있지 않다고 확신합니다.

나는 이미 레이어를 다루는 것의 차이점을 언급했습니다. 모의 테스트는 외부 접근 방식을 지원하는 반면 도메인 모델 아웃 스타일을 선호하는 개발자는 클래식 테스트를 선호하는 경향이 있습니다.

더 작은 수준에서 나는 모의객체 테스터가 값을 반환하는 메서드에서 벗어나 수집 객체에 작용하는 메서드를 선호하는 경향이 있음을 알아차렸습니다. 보고서 문자열을 생성하기 위해 개체 그룹에서 정보를 수집하는 동작의 예를 살펴보십시오. 이를 수행하는 일반적인 방법은 보고 메서드가 다양한 개체에서 메서드를 반환하는 문자열을 호출하도록 하고 결과 문자열을 임시 변수로 조합하는 것입니다. 모의객체 테스터는 문자열 버퍼를 다양한 객체에 전달하고 다양한 문자열을 버퍼에 추가하도록 하여 문자열 버퍼를 수집 매개변수로 취급할 가능성이 더 큽니다.

Mockist 테스터는 '기차 사고'를 피하는 방법에 대해 더 많이 이야기 getThis().getThat().getTheOther()합니다. 메소드 체인을 피하는 것은 Demeter의 법칙을 따르는 것으로도 알려져 있습니다. 메소드 체인이 냄새인 반면, 포워딩 메소드로 인해 부풀려진 중간 남자 객체의 반대 문제도 냄새입니다. (저는 항상 데메테르의 제안이라고 하면 데메테르의 법칙이 더 편할 것이라고 생각했습니다.)

객체 지향 설계에서 사람들이 이해하기 가장 어려운 것 중 하나는 "묻지 말라고" 원칙입니다 . 이 원칙 은 클라이언트 코드에서 수행하도록 객체에서 데이터를 추출하는 대신 객체에게 어떤 작업을 수행하도록 권장합니다. Mockists는 Mockist 테스팅을 사용하는 것이 이것을 촉진하고 오늘날 너무 많은 코드에 만연한 getter 색종이 조각을 피하는 데 도움이 된다고 말합니다. 고전주의자들은 이것을 하는 다른 많은 방법이 있다고 주장합니다.

상태 기반 검증의 알려진 문제는 검증을 지원하기 위한 쿼리 메서드만 생성할 수 있다는 것입니다. 순전히 테스트용으로 객체의 API에 메서드를 추가하는 것은 결코 편하지 않습니다. 동작 검증을 사용하면 해당 문제를 피할 수 있습니다. 이에 대한 반론은 그러한 수정이 일반적으로 실제로는 미미하다는 것입니다.

Mockists는 역할 인터페이스를 선호 하고 이러한 스타일의 테스트를 사용하면 더 많은 역할 인터페이스를 권장한다고 주장합니다. 각 협업은 개별적으로 조롱되고 따라서 역할 인터페이스로 전환될 가능성이 더 높기 때문입니다. 따라서 보고서를 생성하기 위해 문자열 버퍼를 사용하는 위의 예에서 mockist는 문자열 버퍼에 의해 구현 될 수 있는 해당 도메인에서 의미가 있는 특정 역할을 발명할 가능성이 더 높습니다 .

이러한 디자인 스타일의 차이가 대부분의 모의 사용자에게 핵심적인 동기라는 것을 기억하는 것이 중요합니다. TDD의 기원은 진화적 설계를 지원하는 강력한 자동 회귀 테스트를 얻고자 하는 열망이었습니다. 그 과정에서 실무자들은 테스트를 작성하는 것이 먼저 디자인 프로세스를 크게 개선한다는 것을 발견했습니다. Mockists는 어떤 종류의 디자인이 좋은 디자인인지에 대한 강한 아이디어를 가지고 있으며 주로 사람들이 이 디자인 스타일을 개발하는 데 도움이 되는 모의 라이브러리를 개발했습니다.

### 중요성 숨김 (테스트 격리)

이런 행동(동작)의 단위는 몇개의 클래스가 조립된 형태일 수도 있고, 한 클래스 내부에서만 있을 수도 있고, 한줄의 메소드일 수도 있다.

모의자 테스트가 있는 시스템에 버그를 도입하면 일반적으로 SUT에 버그가 포함된 테스트만 실패하게 됩니다. 그러나 고전적인 접근 방식을 사용하면 클라이언트 개체에 대한 모든 테스트도 실패할 수 있으며, 이는 버그가 있는 개체가 다른 개체의 테스트에서 공동 작업자로 사용되는 경우 실패로 이어집니다. 결과적으로 많이 사용되는 개체에서 오류가 발생하면 시스템 전체에서 테스트가 실패하는 파급 효과가 발생합니다.

Mockist 테스터는 이것을 주요 문제로 간주합니다. 오류의 원인을 찾아 수정하기 위해 많은 디버깅이 발생합니다. 그러나 고전주의자들은 이것을 문제의 원인으로 표현하지 않습니다. 일반적으로 범인은 어떤 테스트가 실패했는지 살펴봄으로써 비교적 쉽게 발견할 수 있으며 개발자는 다른 실패가 근본 오류에서 파생된 것임을 알 수 있습니다. 또한 정기적으로 테스트하는 경우(꼭 해야 하는 대로) 손상이 마지막으로 편집한 항목으로 인해 발생했다는 것을 알고 있으므로 결함을 찾는 것이 어렵지 않습니다.

여기에서 중요할 수 있는 한 가지 요소는 테스트의 세분성입니다. 클래식 테스트는 여러 실제 개체를 실행하기 때문에 하나가 아닌 개체 클러스터에 대한 기본 테스트로 단일 테스트를 찾는 경우가 많습니다. 해당 클러스터가 많은 개체에 걸쳐 있는 경우 버그의 실제 소스를 찾는 것이 훨씬 더 어려울 수 있습니다. 여기서 일어나는 일은 테스트가 너무 거칠다는 것입니다.

모의객체 테스트는 이 문제로 고통을 겪을 가능성이 적습니다. 왜냐하면 관례는 기본 이외의 모든 객체를 조롱하는 것이기 때문에 협력자에게는 더 세분화된 테스트가 필요하다는 것을 분명히 하기 때문입니다. 즉, 지나치게 거친 테스트를 사용하는 것이 반드시 클래식 테스트의 실패가 아니라 클래식 테스트를 제대로 수행하지 못하는 것입니다. 좋은 경험 법칙은 모든 클래스에 대해 세분화된 테스트를 분리하는 것입니다. 클러스터는 때때로 합리적이지만 매우 적은 수의 개체로 제한되어야 합니다(6개 이하). 또한 지나치게 거친 테스트로 인해 디버깅 문제가 발생한 경우 테스트 주도 방식으로 디버그하여 진행하면서 더 세분화된 테스트를 생성해야 합니다.

본질적으로 고전적인 xunit 테스트는 단순한 단위 테스트가 아니라 미니 통합 테스트이기도 합니다. 결과적으로 많은 사람들은 클라이언트 테스트가 객체에 대한 주요 테스트, 특히 클래스가 상호 작용하는 영역을 조사할 때 놓쳤을 수 있는 오류를 포착할 수 있다는 사실을 좋아합니다. 모의 테스트는 그 품질을 잃습니다. 또한 모의객체 테스트에 대한 예상이 정확하지 않아 녹색으로 실행되지만 고유한 오류를 마스킹하는 단위 테스트가 발생할 수 있는 위험도 감수해야 합니다.

이 시점에서 어떤 테스트 스타일을 사용하든 시스템 전체에서 작동하는 더 거친 승인 테스트와 결합해야 한다는 점을 강조해야 합니다. 나는 종종 승인 테스트를 사용하여 늦게 프로젝트를 접하고 후회했습니다.


## 그럼에도 써야할 곳

### 모의객체가 효율적인 곳

하지만 그 전에 극단적인 경우를 보겠습니다.  
가끔은 어색한 협업이 아니더라도 상태 확인을 사용하기 정말 어려운 일에 직면하게 됩니다.  
이것의 좋은 예는 캐시입니다.  
캐시의 요점은 캐시의 적중 여부를 상태에서 알 수 없다는 것입니다.  
이는 하드 코어 클래식 TDDer에서도 동작 검증이 현명한 선택이 될 수 있는 경우입니다.  
양방향에 다른 예외가 있다고 확신합니다.

## 정리

테스트가 과도하게 명세를 알면 안된다.  
테스트 더블을 적극적으로 사용할 수록, **구현의 세부사항과 테스트 간의 결합도가 높아진다**.  
